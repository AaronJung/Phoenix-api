package com.ctre.phoenix.motorcontrol.can;
import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.IMotorControllerEnhanced;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.LimitSwitchNormal;
import com.ctre.phoenix.motorcontrol.LimitSwitchSource;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.VelocityMeasPeriod;
import com.ctre.phoenix.motorcontrol.can.MotControllerJNI;

import edu.wpi.first.wpilibj.hal.FRCNetComm.tResourceType;
import edu.wpi.first.wpilibj.hal.HAL;
/**
 * CTRE Talon SRX Motor Controller when used on CAN Bus.
 */
public class TalonSRX extends com.ctre.phoenix.motorcontrol.can.BaseMotorController
		implements IMotorControllerEnhanced {

	public TalonSRX(int deviceNumber) {
		super(deviceNumber | 0x02040000);
		HAL.report(tResourceType.kResourceType_CANTalonSRX, deviceNumber + 1);
	}
	/**
	 * Sets the period of the given status frame.
	 *
	 * User ensure CAN Bus utilization is not high.
	 *
	 * This setting is not persistent and is lost when device is reset.
	 * If this is a concern, calling application can use HasReset()
	 * to determine if the status frame needs to be reconfigured.
	 *
	 * @param frame
	 *            Frame whose period is to be changed.
	 * @param periodMs
	 *            Period in ms for the given frame.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for
	 *            config success and report an error if it times out.
	 *            If zero, no blocking or checking is performed.
	 * @return Error Code generated by function. 0 indicates no error.
	 */
	public ErrorCode setStatusFramePeriod(StatusFrameEnhanced frame, int periodMs, int timeoutMs) {
		return super.setStatusFramePeriod(frame.value, periodMs, timeoutMs);
	}
	public ErrorCode setStatusFramePeriod(StatusFrameEnhanced frame, int periodMs) {
		int timeoutMs = 0;
		return setStatusFramePeriod(frame, periodMs, timeoutMs);
	}
	/**
	 * Gets the period of the given status frame.
	 *
	 * @param frame
	 *            Frame to get the period of.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for
	 *            config success and report an error if it times out.
	 *            If zero, no blocking or checking is performed.
	 * @return Period of the given status frame.
	 */
	public int getStatusFramePeriod(StatusFrameEnhanced frame, int timeoutMs) {

		return super.getStatusFramePeriod(frame, timeoutMs);
	}
	public int getStatusFramePeriod(StatusFrameEnhanced frame) {
		int timeoutMs = 0;
		return getStatusFramePeriod(frame, timeoutMs);
	}
	/**
	 * Configures the period of each velocity sample.
	 * Every 1ms a position value is sampled, and the delta between that sample
	 * and the position sampled kPeriod ms ago is inserted into a filter.
	 * kPeriod is configured with this function.
	 *
	 * @param period
	 *            Desired period for the velocity measurement. @see
	 *            #VelocityMeasPeriod
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for
	 *            config success and report an error if it times out.
	 *            If zero, no blocking or checking is performed.
	 * @return Error Code generated by function. 0 indicates no error.
	 */
	public ErrorCode configVelocityMeasurementPeriod(VelocityMeasPeriod period, int timeoutMs) {
		return super.configVelocityMeasurementPeriod(period, timeoutMs);
	}
	public ErrorCode configVelocityMeasurementPeriod(VelocityMeasPeriod period) {
		int timeoutMs = 0;	
		return configVelocityMeasurementPeriod(period, timeoutMs);
	}
	/**
	 * Sets the number of velocity samples used in the rolling average velocity
	 * measurement.
	 *
	 * @param windowSize
	 *            Number of samples in the rolling average of velocity
	 *            measurement. Valid values are 1,2,4,8,16,32. If another
	 *            value is specified, it will truncate to nearest support value.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for
	 *            config success and report an error if it times out.
	 *            If zero, no blocking or checking is performed.
	 * @return Error Code generated by function. 0 indicates no error.
	 */
	public ErrorCode configVelocityMeasurementWindow(int windowSize, int timeoutMs) {
		return super.configVelocityMeasurementWindow(windowSize, timeoutMs);
	}
	public ErrorCode configVelocityMeasurementWindow(int windowSize) {
		int timeoutMs = 0;
		return configVelocityMeasurementWindow(windowSize, timeoutMs);
	}
	/**
	 * Configures a limit switch for a local/remote source.
	 *
	 * For example, a CAN motor controller may need to monitor the Limit-R pin
	 * of another Talon, CANifier, or local Gadgeteer feedback connector.
	 *
	 * If the sensor is remote, a device ID of zero is assumed.
	 * If that's not desired, use the four parameter version of this function.
	 *
	 * @param type
	 *            Limit switch source.
	 *            User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
	 * @param normalOpenOrClose
	 *            Setting for normally open, normally closed, or disabled. This setting
	 *            matches the web-based configuration drop down.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for
	 *            config success and report an error if it times out.
	 *            If zero, no blocking or checking is performed.
	 * @return Error Code generated by function. 0 indicates no error.
	 */
	public ErrorCode configForwardLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
			int timeoutMs) {

		return super.configForwardLimitSwitchSource(type.value, normalOpenOrClose.value, 0x00000000, timeoutMs);
	}
	public ErrorCode configForwardLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose) {
		int timeoutMs = 0;
		return configForwardLimitSwitchSource(type, normalOpenOrClose, timeoutMs);
	}
	/**
	 * Configures a limit switch for a local/remote source.
	 *
	 * For example, a CAN motor controller may need to monitor the Limit-R pin
	 * of another Talon, CANifier, or local Gadgeteer feedback connector.
	 *
	 * If the sensor is remote, a device ID of zero is assumed. If that's not
	 * desired, use the four parameter version of this function.
	 *
	 * @param type
	 *            Limit switch source. @see #LimitSwitchSource User can choose
	 *            between the feedback connector, remote Talon SRX, CANifier, or
	 *            deactivate the feature.
	 * @param normalOpenOrClose
	 *            Setting for normally open, normally closed, or disabled. This
	 *            setting matches the web-based configuration drop down.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for config
	 *            success and report an error if it times out. If zero, no
	 *            blocking or checking is performed.
	 * @return Error Code generated by function. 0 indicates no error.
	 */
	public ErrorCode configReverseLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
			int timeoutMs) {
		return super.configReverseLimitSwitchSource(type.value, normalOpenOrClose.value, 0x00000000, timeoutMs);
	}
	public ErrorCode configReverseLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose) {
		int timeoutMs = 0;
		return configReverseLimitSwitchSource(type, normalOpenOrClose, timeoutMs);

	}

	// ------ Current Lim ----------//
	/**
	 * Configure the peak allowable current (when current limit is enabled).
	 * 
	 * Current limit is activated when current exceeds the peak limit for longer
	 * than the peak duration. Then software will limit to the continuous limit.
	 * This ensures current limiting while allowing for momentary excess current
	 * events.
	 *
	 * For simpler current-limiting (single threshold) use
	 * ConfigContinuousCurrentLimit() and set the peak to zero:
	 * ConfigPeakCurrentLimit(0).
	 * 
	 * @param amps
	 *            Amperes to limit.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for config
	 *            success and report an error if it times out. If zero, no
	 *            blocking or checking is performed.
	 */
	public ErrorCode configPeakCurrentLimit(int amps, int timeoutMs) {
		int retval =  MotControllerJNI.ConfigPeakCurrentLimit(m_handle, amps, timeoutMs);
		return ErrorCode.valueOf(retval);
	}
	public ErrorCode configPeakCurrentLimit(int amps) {
		int timeoutMs = 0;
		return configPeakCurrentLimit( amps,  timeoutMs);
	}

	/**
	 * Configure the peak allowable duration (when current limit is enabled).
	 *
	 * Current limit is activated when current exceeds the peak limit for longer
	 * than the peak duration. Then software will limit to the continuous limit.
	 * This ensures current limiting while allowing for momentary excess current
	 * events.
	 *
	 * For simpler current-limiting (single threshold) use
	 * ConfigContinuousCurrentLimit() and set the peak to zero:
	 * ConfigPeakCurrentLimit(0).
	 * 
	 * @param milliseconds
	 *            How long to allow current-draw past peak limit.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for config
	 *            success and report an error if it times out. If zero, no
	 *            blocking or checking is performed.
	 */
	public ErrorCode configPeakCurrentDuration(int milliseconds, int timeoutMs) {
		int retval = MotControllerJNI.ConfigPeakCurrentDuration(m_handle, milliseconds, timeoutMs);
		return ErrorCode.valueOf(retval);
	}
	public ErrorCode configPeakCurrentDuration(int milliseconds) {
		int timeoutMs = 0;
		return configPeakCurrentDuration( milliseconds,  timeoutMs);
	}

	/**
	 * Configure the continuous allowable current-draw (when current limit is
	 * enabled).
	 *
	 * Current limit is activated when current exceeds the peak limit for longer
	 * than the peak duration. Then software will limit to the continuous limit.
	 * This ensures current limiting while allowing for momentary excess current
	 * events.
	 *
	 * For simpler current-limiting (single threshold) use
	 * ConfigContinuousCurrentLimit() and set the peak to zero:
	 * ConfigPeakCurrentLimit(0).
	 * 
	 * @param amps
	 *            Amperes to limit.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for config
	 *            success and report an error if it times out. If zero, no
	 *            blocking or checking is performed.
	 */
	public ErrorCode configContinuousCurrentLimit(int amps, int timeoutMs) {
		int retval =  MotControllerJNI.ConfigContinuousCurrentLimit(m_handle, amps, timeoutMs);
		return ErrorCode.valueOf(retval);
	}
	public ErrorCode configContinuousCurrentLimit(int amps) {
		int timeoutMs = 0;
		return configContinuousCurrentLimit( amps,  timeoutMs); 	
	}

	/**
	 * Enable or disable Current Limit.
	 * 
	 * @param enable
	 *            Enable state of current limit.
	 * @see configPeakCurrentLimit, configPeakCurrentDuration,
	 *      configContinuousCurrentLimit
	 */
	public void enableCurrentLimit(boolean enable) {
		MotControllerJNI.EnableCurrentLimit(m_handle, enable);
	}

	protected ErrorCode IfRemoteUseRemoteLimitSwitch(boolean isForward,
	LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose, int deviceID, int timeoutMs) {
		if(type.value > 0 && type.value < 3) {
			if(isForward) {
				return configForwardLimitSwitchSource(type.getRemote(),
				normalOpenOrClose, deviceID, timeoutMs);
			}
			else {
				return configReverseLimitSwitchSource(type.getRemote(),
				normalOpenOrClose, deviceID, timeoutMs);
			}
		}
		else {
			if(isForward) {
				return configForwardLimitSwitchSource(type, normalOpenOrClose, timeoutMs);
			}
			else {
				return configReverseLimitSwitchSource(type, normalOpenOrClose, timeoutMs);
			}
		}
	}


	protected ErrorCode IfRemoteUseRemoteFeedbackFilter(
		FeedbackDevice feedbackDevice, int deviceID,
		RemoteSensorSource remoteSensorSource, int remoteOrdinal, int timeoutMs) {
		if(feedbackDevice.value > 8) {
			return configRemoteFeedbackFilter(deviceID, remoteSensorSource, remoteOrdinal, timeoutMs);
		}
		else
		{
			return ErrorCode.OK;
		}
	}


	//Fix this return data type at some point
	public ErrorCode configureSlot(TalonSRXSlotConfiguration slot, int pidIdx, int timeoutMs) {
	
		//------ sensor selection ----------//      
	
		configSelectedFeedbackSensor(slot.SelectedFeedbackSensor, pidIdx, timeoutMs);
		configSelectedFeedbackCoefficient(slot.SelectedFeedbackCoefficient, pidIdx, timeoutMs);
		IfRemoteUseRemoteFeedbackFilter(slot.SelectedFeedbackSensor, slot.DeviceID,
		slot.remoteSensorSource, slot.RemoteFeedbackFilter,  timeoutMs);
		configSensorTerm(slot.sensorTerm, (FeedbackDevice) slot.SelectedFeedbackSensor, timeoutMs);
		
		
		//------ General Close loop ----------//    
		config_kP(pidIdx, slot.kP, timeoutMs);
		config_kI(pidIdx, slot.kI, timeoutMs);
		config_kD(pidIdx, slot.kD, timeoutMs);
		config_kF(pidIdx, slot.kF, timeoutMs);
		config_IntegralZone(pidIdx, slot.IntegralZone, timeoutMs);
		configAllowableClosedloopError(pidIdx, slot.AllowableClosedloopError, timeoutMs);
		configMaxIntegralAccumulator(pidIdx, slot.MaxIntegralAccumulator, timeoutMs);
		configClosedLoopPeakOutput(pidIdx, slot.ClosedLoopPeakOutput, timeoutMs);
		configClosedLoopPeriod(pidIdx, slot.ClosedLoopPeriod, timeoutMs);
		
		return ErrorCode.FeatureNotSupported;
	}
	public ErrorCode configureSlot(TalonSRXSlotConfiguration slot, int pidIdx) {
		int timeoutMs = 50;
		return configureSlot(slot,  pidIdx,  timeoutMs);
	}
	public ErrorCode configAllSettings(TalonSRXConfiguration allConfigs, int timeoutMs) {
	
		//----- general output shaping ------------------//
		configOpenloopRamp(allConfigs.OpenloopRamp, timeoutMs);
		configClosedloopRamp(allConfigs.ClosedloopRamp, timeoutMs);
		configPeakOutputForward(allConfigs.PeakOutputForward, timeoutMs);
		configPeakOutputReverse(allConfigs.PeakOutputReverse, timeoutMs);
		configNominalOutputForward(allConfigs.NominalOutputForward, timeoutMs);
		configNominalOutputReverse(allConfigs.NominalOutputReverse, timeoutMs);
		configNeutralDeadband(allConfigs.NeutralDeadband, timeoutMs);
		
		//------ Voltage Compensation ----------//
		configVoltageCompSaturation(allConfigs.VoltageCompSaturation, timeoutMs);
		configVoltageMeasurementFilter(allConfigs.VoltageMeasurementFilter, timeoutMs);
		
		//----- velocity signal conditionaing ------//
		configVelocityMeasurementPeriod(allConfigs.VelocityMeasurementPeriod, timeoutMs);
		configVelocityMeasurementWindow(allConfigs.VelocityMeasurementWindow, timeoutMs);
		
		//------ remote limit switch ----------//   
		configForwardLimitSwitchSource(allConfigs.ForwardLimitSwitchSource, allConfigs.ForwardLimitSwitchNormal, timeoutMs);
		configReverseLimitSwitchSource(allConfigs.ReverseLimitSwitchSource, allConfigs.ReverseLimitSwitchNormal, timeoutMs);
		
		//------ soft limit ----------//
		configForwardSoftLimitThreshold(allConfigs.ForwardSoftLimitThreshold, timeoutMs);
		configReverseSoftLimitThreshold(allConfigs.ReverseSoftLimitThreshold, timeoutMs);
		configForwardSoftLimitEnable(allConfigs.ForwardSoftLimitEnable, timeoutMs);
		configReverseSoftLimitEnable(allConfigs.ReverseSoftLimitEnable, timeoutMs);
		
		//--------Slots---------------//
		
		configureSlot(allConfigs.Slot_0, 0, timeoutMs);
		configureSlot(allConfigs.Slot_1, 1, timeoutMs);
		configureSlot(allConfigs.Slot_2, 2, timeoutMs);
		configureSlot(allConfigs.Slot_3, 3, timeoutMs);
		
		//---------Auxilary Closed Loop Polarity-------------//
		
		configAuxPIDPolarity(allConfigs.AuxPIDPolarity, timeoutMs);
		
		//------ Motion Profile Settings used in Motion Magic  ----------//
		configMotionCruiseVelocity(allConfigs.MotionCruiseVelocity, timeoutMs);
		configMotionAcceleration(allConfigs.MotionAcceleration, timeoutMs);
		
		//------ Motion Profile Buffer ----------//
		configMotionProfileTrajectoryPeriod(allConfigs.MotionProfileTrajectoryPeriod, timeoutMs);
		
		//------ Custom Persistent Params ----------//
		configSetCustomParam(allConfigs.CustomParam_0, 0, timeoutMs);
		configSetCustomParam(allConfigs.CustomParam_0, 1, timeoutMs);
		
		return ErrorCode.FeatureNotSupported;
	}
	
	public ErrorCode configAllSettings(TalonSRXConfiguration allConfigs) {
		int timeoutMs = 50;
		return configAllSettings(allConfigs, timeoutMs);
	}
	public ErrorCode configFactoryDefault(int timeoutMs) {
		TalonSRXConfiguration defaults = new TalonSRXConfiguration();
		configAllSettings(defaults, timeoutMs);
		
		return ErrorCode.FeatureNotSupported;
	}
	public ErrorCode configFactoryDefault() {
		int timeoutMs = 50;
		return configFactoryDefault(timeoutMs);
	
	}


}
